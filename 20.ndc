let input = read_file("input/2024/20.txt").trim;
// let input = "###############
// #...#...#.....#
// #.#.#.#.#.###.#
// #S#...#.#.#...#
// #######.#.#.###
// #######.#.#...#
// #######.#.###.#
// ###..E#...#...#
// ###.#######.###
// #...###...#...#
// #.#####.#.###.#
// #.#...#.#.#...#
// #.#.#.#.#.#.###
// #...#...#...###
// ###############";

let nb4 = [(-1, 0), (1, 0), (0, -1), (0, 1)];
let grid = input.lines;
let width = grid[0].len;
let height = grid.len;


let start, end = (), ();
for r in (0..height), c in (0..width) {
    if grid[r][c] == "S" {
        start = (r, c);
    } else if grid[r][c] == "E" {
        end = (r, c);
    } 
}

let p1_hack = 0;
let seen_backup = None;
fn heuristic(start) {
    let que = Deque();
    que.push_back((start, 0));
    let seen = %{:Inf, start: 0};
    while que.len > 0 {
        let cur, dist = que.pop_front;
        for dir in nb4 {
            let next = cur + dir;
            if next not in seen and next[0] >= 0 and next[0] < height and next[1] >= 0 and next[1] < width and grid[next[0]][next[1]] != "#" {
                seen[next] = dist + 1;
                que.push_back((next, dist + 1));
            }
        }
    }

    return seen;
}

let helper = heuristic(end);

let cheats = %{};
for loc in helper.keys {
    for dy in -20..=20, dx in -20..=20 {
        let distance = abs(dx) + abs(dy);
        if distance > 0 and distance <= 20 {
            let y, x = loc;
            let next = (y + dy, x + dx);
            
            let saved = helper[loc] - helper[next] - distance;
            let jump = (next, loc).sorted;
            if jump not in cheats and saved >= 100 {
                cheats[jump] = saved;
            }
        }
    }
}

let p1 = 0;
for cheat, saved in cheats, if saved >= 100 {
    p1 += 1;
}
print(p1);